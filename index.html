<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geo-Spatial Street Scanner</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- html2canvas for Screenshot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; }
        #map { height: 100%; width: 100%; z-index: 1; background: #f8fafc; }
        
        .scroller::-webkit-scrollbar { width: 6px; }
        .scroller::-webkit-scrollbar-track { background: #f1f1f1; }
        .scroller::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }

        .drawing-cursor { cursor: crosshair !important; }
        .pin-cursor { cursor: cell !important; }

        /* Enhanced Start Node */
        .pulse-icon {
            background: #ef4444;
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            animation: pulse-red 1.5s infinite;
            cursor: pointer !important;
        }

        @keyframes pulse-red {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { transform: scale(1.3); box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        /* Note Marker Style */
        .note-marker {
            background: #fef08a;
            border: 1px solid #eab308;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: bold;
            color: #854d0e;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            white-space: nowrap;
        }

        /* Fix for html2canvas capturing Leaflet transformations */
        .leaflet-zoom-animated {
            will-change: transform;
        }

        /* Screenshotting class to help html2canvas */
        .is-screenshotting .leaflet-control-container {
            display: none !important;
        }
    </style>
</head>
<body class="flex flex-col md:flex-row h-screen bg-gray-100 font-sans">

    <!-- Sidebar Panel -->
    <div class="w-full md:w-96 bg-white shadow-xl z-10 flex flex-col h-1/3 md:h-full transition-all duration-300 relative border-r border-gray-200">
        
        <div class="p-6 bg-gradient-to-r from-blue-600 to-indigo-700 text-white shadow-md">
            <h1 class="text-xl font-bold flex items-center gap-2">
                <i class="fa-solid fa-draw-polygon"></i> Area Scanner
            </h1>
            <p class="text-xs text-blue-100 mt-1 opacity-90">Find all streets inside your custom shape.</p>
        </div>

        <div class="p-4 border-b border-gray-100 bg-gray-50 flex flex-col gap-2">
            <div class="flex gap-2">
                <button id="drawBtn" class="flex-1 bg-white border border-gray-300 text-gray-700 px-4 py-2 rounded-lg text-sm font-medium hover:bg-blue-50 hover:border-blue-300 transition-all flex items-center justify-center gap-2 shadow-sm">
                    <i class="fa-solid fa-pen-nib"></i> <span id="drawBtnText">Start Drawing</span>
                </button>
                <button id="resetBtn" class="bg-white border border-gray-300 text-gray-500 px-3 py-2 rounded-lg hover:text-red-500 hover:border-red-200 transition-all shadow-sm" title="Clear Map">
                    <i class="fa-solid fa-trash"></i>
                </button>
            </div>
            
            <div class="flex gap-2">
                <button id="exportBtn" class="flex-1 bg-white border border-gray-300 text-gray-600 px-3 py-1.5 rounded-lg text-xs font-medium hover:bg-gray-100 transition-all shadow-sm flex items-center justify-center gap-2">
                    <i class="fa-solid fa-file-export"></i> Export
                </button>
                <div class="flex-1 relative cursor-pointer group">
                    <input type="file" id="importFile" accept=".json" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10" title="Import Data">
                    <button class="w-full h-full bg-white border border-gray-300 text-gray-600 px-3 py-1.5 rounded-lg text-xs font-medium group-hover:bg-gray-100 transition-all shadow-sm flex items-center justify-center gap-2">
                        <i class="fa-solid fa-file-import"></i> Import
                    </button>
                </div>
            </div>

            <div class="flex gap-2">
                <button id="commentBtn" class="flex-1 bg-white border border-gray-300 text-gray-700 px-3 py-1.5 rounded-lg text-xs font-medium hover:bg-yellow-50 hover:border-yellow-300 transition-all shadow-sm flex items-center justify-center gap-2">
                    <i class="fa-solid fa-comment-dots"></i> Add Comment
                </button>
                <button id="screenshotBtn" class="flex-1 bg-blue-600 text-white px-3 py-1.5 rounded-lg text-xs font-medium hover:bg-blue-700 transition-all shadow-sm flex items-center justify-center gap-2">
                    <i class="fa-solid fa-camera"></i> Screenshot
                </button>
            </div>

            <button id="finishBtn" class="hidden w-full bg-green-600 text-white px-4 py-2 rounded-lg text-sm font-bold hover:bg-green-700 transition-all shadow-md items-center justify-center gap-2">
                <i class="fa-solid fa-check"></i> Close Shape Now
            </button>
        </div>

        <div id="statusPanel" class="px-6 py-3 bg-blue-50 text-blue-800 text-xs font-medium border-b border-blue-100">
            <i class="fa-solid fa-circle-info mr-1"></i> 
            <span id="statusText">Click "Start Drawing" to begin.</span>
        </div>

        <div class="flex-1 overflow-hidden flex flex-col relative">
            <div class="p-4 bg-gray-50 border-b border-gray-200 text-xs font-semibold text-gray-500 uppercase tracking-wider flex justify-between items-center">
                <span>Streets Found</span>
                <span id="countBadge" class="bg-blue-600 text-white py-0.5 px-2 rounded-full text-[10px] hidden">0</span>
            </div>
            
            <div id="resultsList" class="flex-1 overflow-y-auto scroller p-2 space-y-1">
                <div class="h-full flex flex-col items-center justify-center text-gray-400 p-6 text-center">
                    <i class="fa-solid fa-map text-4xl mb-3 opacity-30"></i>
                    <p class="text-sm">No area selected.</p>
                </div>
            </div>

            <div id="loader" class="absolute inset-0 bg-white/90 z-20 flex flex-col items-center justify-center hidden">
                <i class="fa-solid fa-circle-notch fa-spin text-blue-600 text-2xl mb-2"></i>
                <p class="text-sm font-medium text-gray-600" id="loaderText">Identifying Streets...</p>
            </div>
        </div>
        
        <div class="p-2 text-center text-[10px] text-gray-400 border-t border-gray-100 bg-white">
            Uses OpenStreetMap & Overpass API
        </div>
    </div>

    <div id="map"></div>

    <!-- Custom Modal for Note -->
    <div id="noteModal" class="hidden fixed inset-0 bg-black/50 z-[9999] flex items-center justify-center p-4">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-sm">
            <h3 class="text-lg font-bold text-gray-800 mb-4">Add Map Note</h3>
            <input type="text" id="noteInput" class="w-full border border-gray-300 rounded-lg px-4 py-2 focus:ring-2 focus:ring-blue-500 outline-none mb-4" placeholder="Type your note here...">
            <div class="flex gap-2">
                <button id="cancelNoteBtn" class="flex-1 bg-gray-100 text-gray-600 font-bold py-2 rounded-lg hover:bg-gray-200">Cancel</button>
                <button id="saveNoteBtn" class="flex-1 bg-blue-600 text-white font-bold py-2 rounded-lg hover:bg-blue-700">Save Pin</button>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <script>
        const CONFIG = {
            defaultLat: 14.4208441,
            defaultLng: 121.0187598,
            defaultZoom: 16.5,
            tileUrl: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
            attribution: '&copy; OpenStreetMap'
        };

        const SHAPE_COLORS = ['#3b82f6', '#10b981', '#8b5cf6', '#f59e0b', '#ec4899', '#14b8a6', '#f43f5e'];

        const state = {
            isDrawing: false,
            isCommenting: false,
            pendingNoteLatLng: null,
            points: [],
            markers: [],
            tempLine: null,
            rubberBand: null,
            shapes: [],
            notes: [],
            colorIndex: 0
        };

        const els = {
            map: document.getElementById('map'),
            drawBtn: document.getElementById('drawBtn'),
            finishBtn: document.getElementById('finishBtn'),
            resetBtn: document.getElementById('resetBtn'),
            exportBtn: document.getElementById('exportBtn'),
            importFile: document.getElementById('importFile'),
            commentBtn: document.getElementById('commentBtn'),
            screenshotBtn: document.getElementById('screenshotBtn'),
            statusText: document.getElementById('statusText'),
            resultsList: document.getElementById('resultsList'),
            loader: document.getElementById('loader'),
            loaderText: document.getElementById('loaderText'),
            countBadge: document.getElementById('countBadge'),
            noteModal: document.getElementById('noteModal'),
            noteInput: document.getElementById('noteInput'),
            saveNoteBtn: document.getElementById('saveNoteBtn'),
            cancelNoteBtn: document.getElementById('cancelNoteBtn')
        };

        const map = L.map('map', { 
            doubleClickZoom: false,
            zoomControl: true,
            preferCanvas: true // Canvas rendering helps html2canvas align vector layers better
        }).setView([CONFIG.defaultLat, CONFIG.defaultLng], CONFIG.defaultZoom);

        L.tileLayer(CONFIG.tileUrl, { 
            attribution: CONFIG.attribution, 
            maxZoom: 20,
            crossOrigin: true 
        }).addTo(map);

        setTimeout(() => map.invalidateSize(), 200);

        function toggleDrawingMode() {
            if (state.isCommenting) toggleCommentMode();
            state.isDrawing = !state.isDrawing;
            
            if (state.isDrawing) {
                els.map.classList.add('drawing-cursor');
                els.drawBtn.classList.add('bg-red-50', 'text-red-600', 'border-red-200');
                els.drawBtn.innerHTML = '<i class="fa-solid fa-xmark"></i> <span>Cancel</span>';
                updateStatus("Click map to start drawing your shape.");
                disableMapInteractions();
            } else {
                stopDrawing();
            }
        }

        function stopDrawing() {
            state.isDrawing = false;
            els.map.classList.remove('drawing-cursor');
            els.finishBtn.classList.replace('flex', 'hidden');
            els.drawBtn.classList.remove('bg-red-50', 'text-red-600', 'border-red-200');
            els.drawBtn.innerHTML = '<i class="fa-solid fa-pen-nib"></i> <span>Start Drawing</span>';
            if (state.rubberBand) map.removeLayer(state.rubberBand);
            state.rubberBand = null;
            enableMapInteractions();
        }

        function toggleCommentMode() {
            if (state.isDrawing) stopDrawing();
            state.isCommenting = !state.isCommenting;

            if (state.isCommenting) {
                els.map.classList.add('pin-cursor');
                els.commentBtn.classList.add('bg-yellow-100', 'border-yellow-400', 'text-yellow-700');
                updateStatus("Click anywhere on the map to add a note.");
            } else {
                els.map.classList.remove('pin-cursor');
                els.commentBtn.classList.remove('bg-yellow-100', 'border-yellow-400', 'text-yellow-700');
                updateStatus("Comment mode disabled.");
            }
        }

        function addPoint(e) {
            if (state.isCommenting) {
                state.pendingNoteLatLng = e.latlng;
                els.noteModal.classList.remove('hidden');
                els.noteInput.focus();
                return;
            }

            if (!state.isDrawing) return;

            const latlng = e.latlng;
            state.points.push(latlng);
            const isFirst = state.points.length === 1;
            
            const icon = L.divIcon({
                className: isFirst ? 'pulse-icon' : 'bg-white border-2 border-blue-600 rounded-full',
                iconSize: isFirst ? [20, 20] : [10, 10],
                iconAnchor: isFirst ? [10, 10] : [5, 5]
            });

            const marker = L.marker(latlng, { icon: icon, zIndexOffset: 5000 }).addTo(map);
            
            if (isFirst) {
                marker.on('click', (ev) => {
                    L.DomEvent.stopPropagation(ev);
                    if (state.points.length >= 3) closePolygon();
                });
            }

            state.markers.push(marker);
            updateDrawingLines();
            if (state.points.length >= 3) els.finishBtn.classList.replace('hidden', 'flex');
        }

        function saveNote() {
            const text = els.noteInput.value.trim();
            if (text && state.pendingNoteLatLng) {
                const noteIcon = L.divIcon({
                    className: 'note-marker',
                    html: text,
                    iconSize: null
                });

                const marker = L.marker(state.pendingNoteLatLng, { icon: noteIcon }).addTo(map);
                
                state.notes.push({
                    id: Date.now(),
                    text: text,
                    latlng: state.pendingNoteLatLng,
                    marker: marker
                });

                marker.on('dblclick', () => {
                    map.removeLayer(marker);
                    state.notes = state.notes.filter(n => n.marker !== marker);
                });
            }
            closeNoteModal();
        }

        function closeNoteModal() {
            els.noteModal.classList.add('hidden');
            els.noteInput.value = '';
            state.pendingNoteLatLng = null;
            toggleCommentMode(); 
        }

        function updateDrawingLines() {
            if (state.tempLine) map.removeLayer(state.tempLine);
            if (state.points.length > 1) {
                state.tempLine = L.polyline(state.points, {
                    color: '#2563eb', weight: 4, interactive: false, zIndexOffset: 4000
                }).addTo(map);
            }
        }

        function closePolygon() {
            if (state.points.length < 3) return;
            const color = SHAPE_COLORS[state.colorIndex % SHAPE_COLORS.length];
            state.colorIndex++;

            const newPolygon = L.polygon(state.points, {
                color: color, fillColor: color, fillOpacity: 0.3, weight: 4
            }).addTo(map);

            const shapeId = Date.now().toString();
            state.shapes.push({
                id: shapeId,
                name: `Area ${state.shapes.length + 1}`,
                color: color,
                polygon: newPolygon,
                streets: []
            });

            state.markers.forEach(m => map.removeLayer(m));
            if (state.tempLine) map.removeLayer(state.tempLine);
            const finalPoints = [...state.points];
            state.points = [];
            state.markers = [];
            state.tempLine = null;
            
            stopDrawing();
            renderShapes();
            fetchStreets(finalPoints, shapeId);
        }

        async function takeScreenshot() {
            els.loaderText.textContent = "Processing Map...";
            showLoading(true);
            updateStatus("Preparing high-res capture...");

            // Step 1: Prepare the map for capture
            document.body.classList.add('is-screenshotting');
            
            // Wait for any animations to settle
            await new Promise(r => setTimeout(r, 600));

            try {
                const mapContainer = document.getElementById('map');
                
                // Using a more robust configuration for html2canvas to handle Leaflet's eccentricities
                const canvas = await html2canvas(mapContainer, {
                    useCORS: true,
                    allowTaint: false,
                    backgroundColor: '#f8fafc',
                    logging: false,
                    scale: window.devicePixelRatio || 2,
                    // Filter out UI elements that often glitch or are unnecessary
                    ignoreElements: (element) => {
                        return element.classList.contains('leaflet-control-container') || 
                               element.classList.contains('leaflet-control-zoom');
                    },
                    onclone: (clonedDoc) => {
                        // Ensure cloned map has fixed dimensions and no transitions
                        const clonedMap = clonedDoc.getElementById('map');
                        clonedMap.style.transform = 'none';
                        clonedMap.style.transition = 'none';
                    }
                });
                
                const link = document.createElement('a');
                link.download = `street_scanner_${Date.now()}.png`;
                link.href = canvas.toDataURL('image/png', 1.0);
                link.click();
                updateStatus("Screenshot saved successfully.");
            } catch (err) {
                console.error("Screenshot error:", err);
                updateStatus("Capture failed. Try again.");
            } finally {
                document.body.classList.remove('is-screenshotting');
                showLoading(false);
                els.loaderText.textContent = "Identifying Streets...";
            }
        }

        function clearMap() {
            state.points = [];
            state.markers.forEach(m => map.removeLayer(m));
            if (state.tempLine) map.removeLayer(state.tempLine);
            if (state.rubberBand) map.removeLayer(state.rubberBand);
            state.shapes.forEach(s => map.removeLayer(s.polygon));
            state.notes.forEach(n => map.removeLayer(n.marker));
            
            state.shapes = [];
            state.notes = [];
            state.markers = [];
            state.colorIndex = 0;
            
            renderShapes();
            updateStatus("Map cleared.");
        }

        async function fetchStreets(points, shapeId) {
            showLoading(true);
            const coords = points.map(p => `${p.lat.toFixed(6)} ${p.lng.toFixed(6)}`).join(' ');
            const polyString = `${coords} ${points[0].lat.toFixed(6)} ${points[0].lng.toFixed(6)}`;
            const query = `[out:json][timeout:60];(way["highway"]["name"](poly:"${polyString}"););out tags;`;

            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: query });
                const data = await response.json();
                const names = new Set();
                data.elements.forEach(el => el.tags?.name && names.add(el.tags.name));
                const shape = state.shapes.find(s => s.id === shapeId);
                if (shape) {
                    shape.streets = Array.from(names).sort();
                    renderShapes();
                }
            } catch (e) {
                updateStatus("Overpass API Error.");
            } finally {
                showLoading(false);
            }
        }

        function renderShapes() {
            const uniqueStreets = new Set();
            if (state.shapes.length === 0) {
                els.countBadge.classList.add('hidden');
                els.resultsList.innerHTML = `<div class="h-full flex flex-col items-center justify-center text-gray-400 p-6 text-center"><i class="fa-solid fa-map text-4xl mb-3 opacity-30"></i><p class="text-sm">No area selected.</p></div>`;
                return;
            }

            els.resultsList.innerHTML = state.shapes.map(shape => {
                shape.streets.forEach(s => uniqueStreets.add(s));
                const streetList = shape.streets.length ? shape.streets.map(s => `
                    <div class="bg-gray-50 p-2 rounded border border-gray-100 flex justify-between items-center mb-1 group">
                        <span class="text-xs text-gray-700">${s}</span>
                        <button class="remove-street-btn text-gray-400 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-opacity p-1" data-shape-id="${shape.id}" data-street="${s.replace(/"/g, '&quot;')}"><i class="fa-solid fa-xmark text-xs"></i></button>
                    </div>
                `).join('') : '<p class="text-xs text-gray-400 p-2 italic text-center">No streets found.</p>';

                return `
                <div class="mb-3 bg-white rounded-lg shadow-sm border border-gray-200 overflow-hidden">
                    <div class="p-2 border-b flex justify-between items-center bg-gray-50/80">
                        <div class="flex items-center gap-2 flex-1">
                            <div class="w-3 h-3 rounded-full shadow-sm" style="background-color: ${shape.color}"></div>
                            <input type="text" value="${shape.name}" class="shape-name-input font-bold text-gray-700 bg-transparent w-full text-sm outline-none" data-id="${shape.id}">
                        </div>
                        <button class="delete-shape-btn text-gray-400 hover:text-red-500 p-1" data-id="${shape.id}"><i class="fa-solid fa-trash text-xs"></i></button>
                    </div>
                    <div class="p-2 bg-white max-h-48 overflow-y-auto scroller">${streetList}</div>
                </div>`;
            }).reverse().join('');

            els.countBadge.textContent = uniqueStreets.size;
            els.countBadge.classList.remove('hidden');
        }

        function exportData() {
            const data = {
                shapes: state.shapes.map(s => ({
                    id: s.id, name: s.name, color: s.color, streets: s.streets, coordinates: s.polygon.getLatLngs()
                })),
                notes: state.notes.map(n => ({
                    text: n.text, latlng: n.latlng
                }))
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `streets_export.json`;
            a.click();
        }

        function importData(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    clearMap();
                    
                    if (data.shapes) {
                        data.shapes.forEach(item => {
                            const poly = L.polygon(item.coordinates, {
                                color: item.color, fillColor: item.color, fillOpacity: 0.3, weight: 4
                            }).addTo(map);
                            state.shapes.push({ ...item, polygon: poly });
                        });
                    }
                    if (data.notes) {
                        data.notes.forEach(note => {
                            const icon = L.divIcon({ className: 'note-marker', html: note.text, iconSize: null });
                            const m = L.marker(note.latlng, { icon: icon }).addTo(map);
                            state.notes.push({ ...note, marker: m });
                        });
                    }
                    renderShapes();
                } catch (err) { updateStatus("Import Failed."); }
            };
            reader.readAsText(file);
        }

        function updateStatus(msg) { els.statusText.innerHTML = msg; }
        function showLoading(show) { els.loader.classList.toggle('hidden', !show); }
        function disableMapInteractions() { map.dragging.disable(); map.scrollWheelZoom.disable(); }
        function enableMapInteractions() { map.dragging.enable(); map.scrollWheelZoom.enable(); }

        els.drawBtn.addEventListener('click', toggleDrawingMode);
        els.resetBtn.addEventListener('click', clearMap);
        els.exportBtn.addEventListener('click', exportData);
        els.importFile.addEventListener('change', importData);
        els.finishBtn.addEventListener('click', closePolygon);
        els.commentBtn.addEventListener('click', toggleCommentMode);
        els.screenshotBtn.addEventListener('click', takeScreenshot);
        els.saveNoteBtn.addEventListener('click', saveNote);
        els.cancelNoteBtn.addEventListener('click', closeNoteModal);

        map.on('click', addPoint);
        map.on('mousemove', (e) => {
            if (state.isDrawing && state.points.length > 0) {
                if (state.rubberBand) map.removeLayer(state.rubberBand);
                state.rubberBand = L.polyline([state.points[state.points.length - 1], e.latlng], {
                    color: '#2563eb', weight: 2, dashArray: '5, 5', opacity: 0.5, interactive: false, zIndexOffset: 4500
                }).addTo(map);
            }
        });

        els.resultsList.addEventListener('click', (e) => {
            const deleteBtn = e.target.closest('.delete-shape-btn');
            if (deleteBtn) {
                const id = deleteBtn.dataset.id;
                const idx = state.shapes.findIndex(s => s.id === id);
                map.removeLayer(state.shapes[idx].polygon);
                state.shapes.splice(idx, 1);
                renderShapes();
                return;
            }
            const removeBtn = e.target.closest('.remove-street-btn');
            if (removeBtn) {
                const shape = state.shapes.find(s => s.id === removeBtn.dataset.shapeId);
                shape.streets = shape.streets.filter(s => s !== removeBtn.dataset.street);
                renderShapes();
            }
        });
    </script>
</body>
</html>
